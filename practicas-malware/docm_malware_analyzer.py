#!/usr/bin/env python3
"""
DOCM Malware Analyzer
Script para análisis de archivos .docm con macros maliciosas
Autor: Notolac
"""

import os
import sys
import zipfile
import tempfile
import shutil
import re
import json
import hashlib
import base64
from pathlib import Path
from datetime import datetime
import argparse

# Importaciones opcionales con manejo de errores
try:
    import olefile

    OLEFILE_AVAILABLE = True
except ImportError:
    OLEFILE_AVAILABLE = False
    print("[!] oletools no disponible. Instalar con: pip install oletools")

try:
    from oletools.olevba import VBA_Parser
    from oletools import mraptor

    OLETOOLS_AVAILABLE = True
except ImportError:
    OLETOOLS_AVAILABLE = False
    print("[!] oletools no disponible. Instalar con: pip install oletools")


class DOCMAnalyzer:
    def __init__(self, file_path):
        self.file_path = Path(file_path)
        self.temp_dir = None
        self.extracted_files = []
        self.vba_code = []
        self.embedded_files = []
        self.suspicious_indicators = []
        self.analysis_report = {
            "filename": self.file_path.name,
            "file_size": 0,
            "md5": "",
            "sha256": "",
            "analysis_timestamp": datetime.now().isoformat(),
            "macros_found": False,
            "embedded_files": [],
            "vba_code": [],
            "suspicious_indicators": [],
            "extracted_python_files": [],
        }

    def calculate_hashes(self):
        """Calcula hashes MD5 y SHA256 del archivo"""
        try:
            with open(self.file_path, "rb") as f:
                content = f.read()
                self.analysis_report["file_size"] = len(content)
                self.analysis_report["md5"] = hashlib.md5(content).hexdigest()
                self.analysis_report["sha256"] = hashlib.sha256(content).hexdigest()
            print(f"[+] MD5: {self.analysis_report['md5']}")
            print(f"[+] SHA256: {self.analysis_report['sha256']}")
        except Exception as e:
            print(f"[-] Error calculando hashes: {e}")

    def extract_docm_structure(self):
        """Extrae la estructura del archivo .docm (es un ZIP)"""
        try:
            self.temp_dir = tempfile.mkdtemp(prefix="docm_analysis_")
            print(f"[+] Extrayendo estructura en: {self.temp_dir}")

            with zipfile.ZipFile(self.file_path, "r") as zip_file:
                zip_file.extractall(self.temp_dir)
                self.extracted_files = zip_file.namelist()

            print(f"[+] Archivos extraídos: {len(self.extracted_files)}")
            for file in self.extracted_files:
                print(f"    - {file}")

            return True
        except Exception as e:
            print(f"[-] Error extrayendo estructura: {e}")
            return False

    def analyze_vba_macros(self):
        """Analiza macros VBA usando oletools"""
        if not OLETOOLS_AVAILABLE:
            print("[!] oletools no disponible para análisis de macros")
            return

        try:
            print("[+] Analizando macros VBA...")
            vba_parser = VBA_Parser(str(self.file_path))

            if vba_parser.detect_vba_macros():
                self.analysis_report["macros_found"] = True
                print("[+] Macros VBA detectadas!")

                for (
                    filename,
                    stream_path,
                    vba_filename,
                    vba_code,
                ) in vba_parser.extract_macros():
                    if vba_code:
                        macro_info = {
                            "filename": vba_filename,
                            "stream_path": stream_path,
                            "code": vba_code,
                        }
                        self.vba_code.append(macro_info)
                        self.analysis_report["vba_code"].append(macro_info)

                        print(f"[+] Macro encontrada en: {vba_filename}")
                        self.analyze_vba_content(vba_code)

                vba_parser.close()
            else:
                print("[-] No se detectaron macros VBA")

        except Exception as e:
            print(f"[-] Error analizando macros: {e}")

    def analyze_vba_content(self, vba_code):
        """Analiza el contenido de las macros VBA en busca de indicadores sospechosos"""
        suspicious_patterns = [
            r"Shell\s*\(",
            r"CreateObject\s*\(",
            r"GetObject\s*\(",
            r"WScript\.Shell",
            r"Environ\s*\(",
            r"URLDownloadToFile",
            r"InternetOpen",
            r"WinExec",
            r"ShellExecute",
            r"cmd\.exe",
            r"powershell",
            r"\.exe",
            r"http[s]?://",
            r"base64",
            r"decode",
            r"Chr\(",
            r"Asc\(",
            r'\.py["\']',  # Buscar referencias a archivos Python
            r"python",
            r"\.bat",
            r"\.scr",
            r"\.com",
        ]

        for pattern in suspicious_patterns:
            matches = re.finditer(pattern, vba_code, re.IGNORECASE)
            for match in matches:
                indicator = {
                    "type": "VBA_Suspicious_Pattern",
                    "pattern": pattern,
                    "match": match.group(),
                    "position": match.start(),
                }
                self.suspicious_indicators.append(indicator)
                self.analysis_report["suspicious_indicators"].append(indicator)

    def search_embedded_files(self):
        """Busca archivos embebidos, especialmente archivos Python"""
        print("[+] Buscando archivos embebidos...")

        if not self.temp_dir:
            return

        for root, dirs, files in os.walk(self.temp_dir):
            for file in files:
                file_path = os.path.join(root, file)
                try:
                    with open(file_path, "rb") as f:
                        content = f.read()

                    # Buscar archivos Python embebidos
                    self.search_python_code(content, file_path)

                    # Buscar otros archivos embebidos por firma
                    self.detect_embedded_by_signature(content, file_path)

                except Exception as e:
                    print(f"[-] Error leyendo {file_path}: {e}")

    def search_python_code(self, content, file_path):
        """Busca código Python embebido"""
        try:
            # Buscar código Python en texto plano
            text_content = content.decode("utf-8", errors="ignore")

            # Patrones comunes de código Python
            python_patterns = [
                r"import\s+\w+",
                r"from\s+\w+\s+import",
                r"def\s+\w+\s*\(",
                r"class\s+\w+\s*:",
                r'if\s+__name__\s*==\s*["\']__main__["\']',
                r"print\s*\(",
                r"#!/usr/bin/env python",
                r"#!/usr/bin/python",
            ]

            python_matches = 0
            for pattern in python_patterns:
                if re.search(pattern, text_content, re.IGNORECASE):
                    python_matches += 1

            if python_matches >= 2:  # Si encuentra al menos 2 patrones Python
                print(f"[+] Posible código Python encontrado en: {file_path}")
                self.extract_python_code(text_content, file_path)

        except Exception as e:
            print(f"[-] Error buscando código Python: {e}")

    def extract_python_code(self, content, source_file):
        """Extrae y guarda código Python encontrado"""
        try:
            # Crear directorio de salida para archivos Python
            output_dir = Path("extracted_python_files")
            output_dir.mkdir(exist_ok=True)

            # Buscar bloques de código Python más específicos
            python_blocks = re.findall(
                r"((?:import\s+\w+|from\s+\w+\s+import).*?)(?=\n\s*\n|\Z)",
                content,
                re.DOTALL | re.IGNORECASE,
            )

            for i, block in enumerate(python_blocks):
                if len(block.strip()) > 50:  # Solo bloques significativos
                    output_file = output_dir / f"extracted_python_{i+1}.py"
                    with open(output_file, "w", encoding="utf-8") as f:
                        f.write(block)

                    self.analysis_report["extracted_python_files"].append(
                        {
                            "source": source_file,
                            "output_file": str(output_file),
                            "size": len(block),
                        }
                    )

                    print(f"[+] Código Python extraído: {output_file}")

        except Exception as e:
            print(f"[-] Error extrayendo código Python: {e}")

    def detect_embedded_by_signature(self, content, file_path):
        """Detecta archivos embebidos por firmas de archivo"""
        signatures = {
            b"MZ": "PE Executable",
            b"PK": "ZIP Archive",
            b"\x50\x4b\x03\x04": "ZIP File",
            b"\x50\x4b\x05\x06": "ZIP End",
            b"%PDF": "PDF Document",
            b"\x89PNG": "PNG Image",
            b"\xff\xd8\xff": "JPEG Image",
            b"GIF8": "GIF Image",
            b"RIFF": "RIFF File",
            b"\x00\x00\x01\x00": "ICO File",
        }

        for sig, file_type in signatures.items():
            if sig in content:
                embedded_file = {
                    "source": file_path,
                    "type": file_type,
                    "signature": sig.hex(),
                    "size": len(content),
                }
                self.embedded_files.append(embedded_file)
                self.analysis_report["embedded_files"].append(embedded_file)
                print(f"[+] Archivo embebido detectado: {file_type} en {file_path}")

    def analyze_strings(self):
        """Extrae y analiza strings sospechosas"""
        try:
            with open(self.file_path, "rb") as f:
                content = f.read()

            # Extraer strings legibles
            strings = re.findall(b"[A-Za-z0-9/\\-:.,_$%@()]{4,}", content)

            suspicious_strings = []
            for string in strings:
                try:
                    decoded = string.decode("utf-8", errors="ignore")
                    if any(
                        keyword in decoded.lower()
                        for keyword in [
                            "http",
                            "download",
                            "execute",
                            "shell",
                            "cmd",
                            "powershell",
                            "python",
                            ".py",
                        ]
                    ):
                        suspicious_strings.append(decoded)
                except:
                    continue

            if suspicious_strings:
                print(f"[+] Strings sospechosas encontradas: {len(suspicious_strings)}")
                for s in suspicious_strings[:10]:  # Mostrar solo las primeras 10
                    print(f"    - {s}")

        except Exception as e:
            print(f"[-] Error analizando strings: {e}")

    def cleanup(self):
        """Limpia archivos temporales"""
        if self.temp_dir and os.path.exists(self.temp_dir):
            shutil.rmtree(self.temp_dir)

    def generate_report(self):
        """Genera reporte de análisis"""
        report_file = (
            f"malware_analysis_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        )

        try:
            with open(report_file, "w", encoding="utf-8") as f:
                json.dump(self.analysis_report, f, indent=2, ensure_ascii=False)

            print(f"[+] Reporte generado: {report_file}")

            # Resumen en consola
            print("\n" + "=" * 60)
            print("RESUMEN DEL ANÁLISIS")
            print("=" * 60)
            print(f"Archivo: {self.analysis_report['filename']}")
            print(f"Tamaño: {self.analysis_report['file_size']} bytes")
            print(f"MD5: {self.analysis_report['md5']}")
            print(
                f"Macros encontradas: {'Sí' if self.analysis_report['macros_found'] else 'No'}"
            )
            print(f"Archivos embebidos: {len(self.analysis_report['embedded_files'])}")
            print(
                f"Indicadores sospechosos: {len(self.analysis_report['suspicious_indicators'])}"
            )
            print(
                f"Archivos Python extraídos: {len(self.analysis_report['extracted_python_files'])}"
            )

        except Exception as e:
            print(f"[-] Error generando reporte: {e}")

    def run_analysis(self):
        """Ejecuta el análisis completo"""
        print(f"[+] Iniciando análisis de: {self.file_path}")
        print("=" * 60)

        try:
            # Verificar que el archivo existe
            if not self.file_path.exists():
                print(f"[-] El archivo {self.file_path} no existe")
                return False

            # Análisis básico
            self.calculate_hashes()

            # Extraer estructura
            if not self.extract_docm_structure():
                return False

            # Análisis de macros
            self.analyze_vba_macros()

            # Buscar archivos embebidos
            self.search_embedded_files()

            # Análisis de strings
            self.analyze_strings()

            # Generar reporte
            self.generate_report()

            return True

        except Exception as e:
            print(f"[-] Error durante el análisis: {e}")
            return False
        finally:
            self.cleanup()


def main():
    parser = argparse.ArgumentParser(
        description="Analizador de malware para archivos .docm"
    )
    parser.add_argument("file", help="Ruta al archivo .docm a analizar")
    parser.add_argument("-v", "--verbose", action="store_true", help="Modo verbose")

    args = parser.parse_args()

    if not os.path.exists(args.file):
        print(f"[-] El archivo {args.file} no existe")
        sys.exit(1)

    analyzer = DOCMAnalyzer(args.file)
    success = analyzer.run_analysis()

    if success:
        print("\n[+] Análisis completado exitosamente")

        # Mostrar archivos Python extraídos si los hay
        if analyzer.analysis_report["extracted_python_files"]:
            print("\n[+] Archivos Python extraídos:")
            for py_file in analyzer.analysis_report["extracted_python_files"]:
                print(
                    f"    - {py_file['output_file']} (Tamaño: {py_file['size']} bytes)"
                )
                print(f"      Fuente: {py_file['source']}")
    else:
        print("[-] El análisis falló")
        sys.exit(1)


if __name__ == "__main__":
    main()
