import ipaddress
import requests
import json
import os
import logging
import datetime
import sys
import time
import re
from datetime import datetime
import markdown
from fpdf import FPDF

# Configuración de logging
log_dir = "logs"
os.makedirs(log_dir, exist_ok=True)
log_file = os.path.join(log_dir, f"ip_check_{datetime.now().strftime('%Y%m%d')}.log")

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[logging.FileHandler(log_file), logging.StreamHandler()],
)

# Crear directorio para informes
reports_dir = "reports"
os.makedirs(reports_dir, exist_ok=True)


# Clase principal para el análisis de IP
class IPAnalyzer:
    def __init__(self):
        self.ip = None
        self.results = {}

    def validate_ip(self, ip_str):
        """Valida que la dirección IP sea una IPv4 pública válida"""
        try:
            ip_obj = ipaddress.ip_address(ip_str)

            # Verificar que sea IPv4
            if not isinstance(ip_obj, ipaddress.IPv4Address):
                return False, "La dirección IP debe ser una IPv4"

            # Verificar que sea pública
            if ip_obj.is_private:
                return (
                    False,
                    "La dirección IP es privada. Por favor, ingrese una IP pública",
                )

            return True, str(ip_obj)
        except ValueError:
            return False, "Formato de dirección IP inválido"

    def get_user_input(self):
        """Solicita al usuario ingresar una dirección IP"""
        while True:
            ip_str = input("Ingrese la dirección IPv4 pública a analizar: ")
            is_valid, message = self.validate_ip(ip_str)

            if is_valid:
                self.ip = message
                logging.info(f"Analizando IP: {self.ip}")
                return
            else:
                print(f"Error: {message}")
                logging.warning(
                    f"Intento fallido con entrada: {ip_str}. Error: {message}"
                )

    def analyze(self):
        """Ejecuta todos los análisis en las diferentes APIs"""
        try:
            self.results["virustotal"] = self.check_virustotal()
            self.results["abuseipdb"] = self.check_abuseipdb()
            self.results["whois"] = self.get_whois()
            # Más fuentes pueden ser agregadas aquí

            self.generate_reports()

        except Exception as e:
            logging.error(f"Error durante el análisis: {str(e)}")
            print(f"Ha ocurrido un error durante el análisis: {str(e)}")

    def check_virustotal(self):
        """Consulta la API de VirusTotal para obtener información sobre la IP"""
        try:
            # Reemplazar con tu API key de VirusTotal
            api_key = os.getenv("VIRUSTOTAL_API_KEY", "")
            if not api_key:
                logging.warning(
                    "No se encontró API key para VirusTotal. Configurar variable de entorno VIRUSTOTAL_API_KEY"
                )
                return "No se pudo consultar - API key no configurada"

            url = f"https://www.virustotal.com/api/v3/ip_addresses/{self.ip}"
            headers = {"x-apikey": api_key}

            response = requests.get(url, headers=headers)

            if response.status_code == 200:
                data = response.json()
                result = {}

                # Extraer información relevante
                attrs = data.get("data", {}).get("attributes", {})

                result["reputation"] = attrs.get("reputation", "N/A")
                result["country"] = attrs.get("country", "N/A")

                # Estadísticas de detección
                stats = attrs.get("last_analysis_stats", {})
                result["detecciones"] = {
                    "maliciosas": stats.get("malicious", 0),
                    "sospechosas": stats.get("suspicious", 0),
                    "limpias": stats.get("harmless", 0),
                    "no_detectadas": stats.get("undetected", 0),
                }

                return result
            elif response.status_code == 401:
                logging.error("Error de autenticación con VirusTotal API")
                return "Error de autenticación - Verificar API key"
            elif response.status_code == 429:
                logging.warning("Límite de peticiones alcanzado en VirusTotal API")
                return "Límite de peticiones alcanzado"
            else:
                logging.error(f"Error consultando VirusTotal: {response.status_code}")
                return f"Error: Código de respuesta {response.status_code}"

        except Exception as e:
            logging.error(f"Error en consulta a VirusTotal: {str(e)}")
            return f"Error: {str(e)}"

    def check_abuseipdb(self):
        """Consulta la API de AbuseIPDB para obtener información sobre la IP"""
        try:
            # Reemplazar con tu API key de AbuseIPDB
            api_key = os.getenv("ABUSEIPDB_API_KEY", "")
            if not api_key:
                logging.warning(
                    "No se encontró API key para AbuseIPDB. Configurar variable de entorno ABUSEIPDB_API_KEY"
                )
                return "No se pudo consultar - API key no configurada"

            url = "https://api.abuseipdb.com/api/v2/check"

            querystring = {"ipAddress": self.ip, "maxAgeInDays": "90"}

            headers = {"Accept": "application/json", "Key": api_key}

            response = requests.get(url, headers=headers, params=querystring)

            if response.status_code == 200:
                data = response.json().get("data", {})
                result = {}

                result["puntaje_abuso"] = data.get("abuseConfidenceScore", "N/A")
                result["país"] = data.get("countryCode", "N/A")
                result["usos"] = data.get("usageType", "N/A")
                result["dominios"] = data.get("domain", "N/A")
                result["isp"] = data.get("isp", "N/A")
                result["reportes_totales"] = data.get("totalReports", 0)

                return result
            elif response.status_code == 401:
                logging.error("Error de autenticación con AbuseIPDB API")
                return "Error de autenticación - Verificar API key"
            elif response.status_code == 429:
                logging.warning("Límite de peticiones alcanzado en AbuseIPDB API")
                return "Límite de peticiones alcanzado"
            else:
                logging.error(f"Error consultando AbuseIPDB: {response.status_code}")
                return f"Error: Código de respuesta {response.status_code}"

        except Exception as e:
            logging.error(f"Error en consulta a AbuseIPDB: {str(e)}")
            return f"Error: {str(e)}"

    def get_whois(self):
        """Obtiene información WHOIS sobre la IP"""
        try:
            # Usamos la API de ipwhois.io que no requiere API key para consultas básicas
            url = f"https://ipwhois.app/json/{self.ip}"

            response = requests.get(url)

            if response.status_code == 200:
                data = response.json()
                result = {}

                # Extraer información relevante
                result["país"] = data.get("country", "N/A")
                result["region"] = data.get("region", "N/A")
                result["ciudad"] = data.get("city", "N/A")
                result["isp"] = data.get("isp", "N/A")
                result["org"] = data.get("org", "N/A")
                result["asn"] = data.get("asn", "N/A")

                return result
            elif response.status_code == 429:
                logging.warning("Límite de peticiones alcanzado en WHOIS API")
                return "Límite de peticiones alcanzado"
            else:
                logging.error(f"Error consultando WHOIS: {response.status_code}")
                return f"Error: Código de respuesta {response.status_code}"

        except Exception as e:
            logging.error(f"Error en consulta WHOIS: {str(e)}")
            return f"Error: {str(e)}"

    def generate_reports(self):
        """Genera informes en formatos MD y PDF"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        base_filename = f"ip_report_{self.ip.replace('.', '_')}_{timestamp}"

        md_path = os.path.join(reports_dir, f"{base_filename}.md")
        pdf_path = os.path.join(reports_dir, f"{base_filename}.pdf")

        # Generar informe MD
        self.generate_md_report(md_path)

        # Convertir MD a PDF
        self.generate_pdf_report(md_path, pdf_path)

        print(f"Informes generados:")
        print(f"- Markdown: {md_path}")
        print(f"- PDF: {pdf_path}")
        logging.info(f"Informes generados en {md_path} y {pdf_path}")

    def generate_md_report(self, filepath):
        """Genera el informe en formato Markdown"""
        with open(filepath, "w") as f:
            f.write(f"# Reporte de análisis para la IP: {self.ip}\n\n")
            f.write(f"Fecha y hora: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")

            for source, data in self.results.items():
                f.write(f"## Resultados de {source.capitalize()}\n\n")

                if isinstance(data, dict):
                    for key, value in data.items():
                        if isinstance(value, dict):
                            f.write(f"### {key}:\n")
                            for subkey, subvalue in value.items():
                                f.write(f"- **{subkey}**: {subvalue}\n")
                        elif isinstance(value, list):
                            f.write(f"### {key}:\n")
                            if not value:
                                f.write("- No hay datos disponibles\n")
                            else:
                                for item in value[
                                    :10
                                ]:  # Limitamos a 10 items para no saturar el informe
                                    f.write(f"- {item}\n")
                                if len(value) > 10:
                                    f.write(f"- ... y {len(value) - 10} más\n")
                        else:
                            f.write(f"- **{key}**: {value}\n")
                elif isinstance(data, str):
                    f.write(data + "\n")
                elif data is None:
                    f.write("No se pudo obtener información de esta fuente.\n")
                else:
                    f.write(str(data) + "\n")

                f.write("\n---\n\n")

    def generate_pdf_report(self, md_path, pdf_path):
        """Convierte el informe Markdown a PDF"""
        # Leer el archivo markdown
        with open(md_path, "r") as f:
            md_content = f.read()

        # Convertir markdown a HTML
        html = markdown.markdown(md_content)

        # Crear PDF
        pdf = FPDF()
        pdf.add_page()
        pdf.set_auto_page_break(auto=True, margin=15)

        # Añadir título
        pdf.set_font("Arial", "B", 16)
        pdf.cell(
            200, 10, f"Reporte de análisis para la IP: {self.ip}", ln=True, align="C"
        )
        pdf.ln(10)

        # Procesar el HTML básico para el cuerpo
        pdf.set_font("Arial", "", 12)

        # Simplificación: dividir por líneas y procesar líneas con formato básico
        for line in md_content.split("\n"):
            if line.startswith("# "):
                pdf.set_font("Arial", "B", 16)
                pdf.cell(0, 10, line[2:], ln=True)
                pdf.set_font("Arial", "", 12)
            elif line.startswith("## "):
                pdf.set_font("Arial", "B", 14)
                pdf.cell(0, 10, line[3:], ln=True)
                pdf.set_font("Arial", "", 12)
            elif line.startswith("### "):
                pdf.set_font("Arial", "B", 13)
                pdf.cell(0, 10, line[4:], ln=True)
                pdf.set_font("Arial", "", 12)
            elif line.startswith("- "):
                pdf.multi_cell(0, 8, line[2:])
            elif line.startswith("---"):
                pdf.line(10, pdf.get_y(), 200, pdf.get_y())
                pdf.ln(5)
            else:
                if line.strip():
                    pdf.multi_cell(0, 8, line)

        # Guardar archivo
        pdf.output(pdf_path)


# Función principal
def main():
    print("\n===== ANALIZADOR DE IPs REPORTADAS =====\n")
    print(
        "Este script analiza direcciones IPv4 públicas en múltiples fuentes de inteligencia de amenazas"
    )
    print("y genera informes en formato Markdown y PDF.\n")

    analyzer = IPAnalyzer()
    analyzer.get_user_input()
    analyzer.analyze()


if __name__ == "__main__":
    main()
